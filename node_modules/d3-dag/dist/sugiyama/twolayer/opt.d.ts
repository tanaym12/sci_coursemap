/**
 * A {@link TwolayerOpt} that is optimal for only the current layer being
 * rearranged.
 *
 * @packageDocumentation
 */
import { Twolayer } from ".";
import { OptChecking } from "../../layout";
/**
 * a {@link Twolayer} for optimal decrossing of a single target layer
 *
 * The opt order operator orders the relevant layer to minimize the number of
 * crossings. This is expensive, but not nearly as expensive as optimizing all
 * crossings initially.
 *
 * Create with {@link twolayerOpt}.
 */
export interface TwolayerOpt extends Twolayer<unknown, unknown> {
    /**
     * set the checking for large dag options
     *
     * Setting to anything but `"fast"` will allow running on larger dags, but
     * the layout may run forever, or crash the vm.
     *
     * (default: `"fast"`)
     */
    check(val: OptChecking): TwolayerOpt;
    /** return the checking of large graphs */
    check(): OptChecking;
    /**
     * set whether to also minimize distance between nodes with common ancestors
     *
     * This adds more variables and constraints so will take longer, but will
     * likely produce a better layout. It is the same as {@link DecrossOpt#dist}.
     *
     * (default: `false`)
     */
    dist(val: boolean): TwolayerOpt;
    /** get whether the current layout minimizes distance */
    dist(): boolean;
    /** @internal flag indicating that this is built in to d3dag and shouldn't error in specific instances */
    readonly d3dagBuiltin: true;
}
/**
 * create a default {@link TwolayerOpt}
 *
 * This is a {@link Twolayer} that optimally removes crossings between the two
 * layers. Because this is local, it might not fully remove link crossings that
 * {@link decrossOpt} will, but it can run on larger dags and will often be
 * faster.
 *
 * @example
 *
 * ```ts
 * const layout = sugiyama().decross(decrossTwoLayer().order(twolayerOpt()));
 * ```
 */
export declare function twolayerOpt(...args: never[]): TwolayerOpt;
