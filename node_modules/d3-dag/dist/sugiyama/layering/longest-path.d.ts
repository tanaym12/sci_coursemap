/**
 * A {@link LayeringLongestPath} that minimizes the height of the final layout
 *
 * @packageDocumentation
 */
import { Layering } from ".";
import { Rank } from "../../graph";
import { U } from "../../utils";
/** longest path operators */
export interface LayeringLongestPathOps<in N = never, in L = never> {
    /** rank operator */
    rank: Rank<N, L>;
}
/** the node datum of a set of operators */
type OpsNodeDatum<Ops extends LayeringLongestPathOps> = Ops extends LayeringLongestPathOps<infer N, never> ? N : never;
/** the link datum of a set of operators */
type OpsLinkDatum<Ops extends LayeringLongestPathOps> = Ops extends LayeringLongestPathOps<never, infer L> ? L : never;
/**
 * a {@link Layering} that minimizes the height of the final layout.
 *
 * This often results in very wide and unpleasing graphs, but is very fast. The
 * layout can go {@link topDown | top-down} or bottom-up, either assigning all roots to layer 0
 * or all leaves to the last layer.
 *
 * Create with {@link layeringLongestPath}.
 */
export interface LayeringLongestPath<Ops extends LayeringLongestPathOps = LayeringLongestPathOps> extends Layering<OpsNodeDatum<Ops>, OpsLinkDatum<Ops>> {
    /**
     * set the {@link Rank}
     *
     * The rank will override the default ordering of nodes for rending top to
     * bottom. Note that unlike {@link layeringSimplex} nodes with the same rank
     * are *not* guaranteed to be on the same layer.
     */
    rank<NewRank extends Rank>(newRank: NewRank): LayeringLongestPath<U<Ops, "rank", NewRank>>;
    /**
     * get the current {@link Rank}.
     */
    rank(): Ops["rank"];
    /**
     * set whether longest path should go top down
     *
     * If set to true, the longest path will start at the top, putting nodes as
     * close to the top as possible.
     *
     * (default: `true`)
     */
    topDown(val: boolean): LayeringLongestPath<Ops>;
    /** get whether or not this is using topDown. */
    topDown(): boolean;
    /** @internal flag indicating that this is built in to d3dag and shouldn't error in specific instances */
    readonly d3dagBuiltin: true;
}
/** default longest path operator */
export type DefaultLayeringLongestPath = LayeringLongestPath<{
    /** unconstrained rank */
    rank: Rank<unknown, unknown>;
}>;
/**
 * create a default {@link LayeringLongestPath}
 *
 * This {@link Layering} operator minimizes the height of the final layout.
 * This often results in very wide and unpleasing graphs, but is very fast. You
 * can set if it goes {@link LayeringLongestPath#topDown}.
 *
 * @example
 *
 * ```ts
 * const layout = sugiyama().layering(layeringLongestPath().topDown(false));
 * ```
 */
export declare function layeringLongestPath(...args: never[]): DefaultLayeringLongestPath;
export {};
